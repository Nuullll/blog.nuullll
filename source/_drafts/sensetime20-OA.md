---
title: 商汤20校招自动驾驶开发在线笔试回忆
date: 2019-08-21 12:43:33
tags:
  - Online Assessment
  - SenseTime
  - Software Development
  - Algorithm
  - Autonomous Cars
hidden: true
categories:
  - geek
---

* 在线笔试：2019年8月19日 19:00-21:30
* 题型：5道硬核编程题，每题20分
* 岗位：自动驾驶开发

*本文为个人参加笔试后的回忆及梳理，不打算公开分享*

*如无特别说明，则题干中的变量均为整数*

## Problem A: 传感器干扰

### 题干回忆

> 现有n个传感器，m个处理器，每个传感器都需要连接到一个处理器。可用的频段共有k个，第i个传感器的工作频段为Di ($1\le D_i \le k$)。
> 当两个传感器工作在同一频段，且连接到相同的处理器时，这两个传感器之间会产生干扰，记为1个干扰对。
> 传感器与处理器间不同的连接方式会决定干扰对的数量，求干扰对最少是多少。

### 输入输出

* 输入
  * 第一行 n m k
  * 第二行n个整数，是各传感器的频段Di
* 输出
  * 第一行 最小干扰对的数量

### 数据范围

* $1 \le n, m \le 10^9$
* $1 \le k \le 10^5 $
* $1 \le D_i \le k $

### 思路

数学问题，鸽笼原理+排列组合直接AC。时间复杂度 $O(n)$


## Problem B: 路测DDL！

### 题干回忆

> 自动驾驶路测场地共有n个路口，m个双向道路，但场地建设仍未完成。第i条道路的长度为Li，在第Ti天才可以完工。
> 现有一紧急路测任务，需要完成从路口s到路口t的测试。由于路测安全员精力有限，路测任务的道路总长度不能超过k，否则会有生命危险！
> 求最早可以在第几天进行路测。

### 输入输出

* 输入
  * 第一行 n m s t k
  * 接下来有m行，每行4个数，si ti Li Ti，分别表示第i条道路的起点路口编号、终点路口编号、长度以及完工时间
* 输出
  * 第一行 最早可以进行路测的时间

### 数据范围

* $1 \le n, m, L_i \le 10^5$
* $1 \le s, t, s_i, t_i \le n$
* $1 \le k, T_i \le 10^9$

### 思路

无向权重图的问题，需要找到s，t之间长度小于等于k且完工时间最早的路径。

#### Brute Force

直接的思路是找到所有路径，保留长度小于等于k的路径，求完工时间的最小值。

可以用 DFS + Backtracking 获得所有路径。考虑完全图，图内任意两定点都相邻，那么路径的数量是$O(n!)$，复杂度过高，应该不能AC。

#### Answer Binary Search

考虑将问题简化：对于给定的k，T，如何判断是否可以在第T天（或更早）进行路测？

原本晚于第T天完工的道路可视为不通，只需判断是否存在小于等于k的路径即可，这样可以转化成最短路径问题。
经典的Dijkstra求最短路径的时间复杂度是$O(n^2)$，用小顶堆或红黑树可以将Dijkstra优化到$O(m\log n)$：[Dijkstra’s Shortest Path Algorithm using priority_queue of STL](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/)

对于这个子问题，每次判断都可以确定原问题答案的上界或下届，因此可以对答案进行二分搜索：
先对所有道路完工时间排序：$O(m\log m)$，再进行二分搜索+最短路径：$O(m\log m \log n)$。这样整体的时间复杂度为 $O(m\log m) + O(m\log m \log n) = O(m\log m \log n)$；若对T进行线性扫描，则时间复杂度为 $O(m^2\log n)$。


## Problem C: 超能力同事

### 题干回忆

> 办公室有一超能力同事小蔡，心情好的时候会以光速帮助其他同事完成手头的任务。每当小蔡决定帮同事完成任务时，会随机选取一个幸运数字x，并光速帮助当前任务数大于x的同事完成任务，使得他们剩余的任务数为x；其余任务数小于等于x的同事任务数则保持不变。
> 现有正常同事n人（不包括小蔡），给定每个人的初始任务数Ti。给定m个依次发生的事件，事件类型有两种：
> A事件：当前第a个同事的任务数变为b
> B事件：小蔡帮助同事完成任务，选取的幸运数字为x
> 求经历m个事件后，每位同事剩余的任务数

### 输入输出

* 输入
  * 第一行 n m
  * 第二行n个数，表示每个同事的初始任务数Ti
  * 接下来有m行，每行表示一个事件，事件A格式为 1 a b，事件B为 2 x
* 输出
  * 第一行n个数，表示最终每个同事的任务数

### 数据范围

* $1 \le n, m \le 10^5$
* $1 \le T_i, b, x \le 10^9$
* $1 \le a \le n$

### 思路

#### Brute Force

按部就班，每个事件发生时对任务数进行更新。若所有人的任务数存在一个vector中，则事件A更新的复杂度是 $O(1)$，事件B更新的复杂度是 $O(n)$。
整体复杂度 $O(mn)$，应该不能完全AC。

#### 设计支持O(1) setAll()操作的数据结构

事件B类似于对数组数据进行setAll操作（实际上原本任务数小于x的数据不会被set，这一点稍后再讨论）。

先考虑如何对数组进行快速的setAll，直接的思路是维护一个全局的数值以及flag来记录setAll的信息，之后再读取数据时，可以通过flag判断数组是否被setAll，以此决定读取全局值或是数组中的值。
但这样的设计会导致setAll->set->read的操作序列发生错误，因为无法判断数组中的值是否是在setAll后写入的。为了解决这个问题，数组中每个位置可再增加一个时间戳，全局的flag也调整成一个全局的时间戳，分别代表对应位置元素被set的时间以及setAll发生的时间。
读取数据时，可判断对应位置的更新时间戳是否晚于setAll时间戳，来决定返回的结果。这样set和setAll的时间复杂度均为 $O(1)$，增加了 $O(n)$ 的空间开销。

但实际上题意中的事件B并不是严格意义上的setAll操作，它只更新比目标值大的数据。可以这样考虑，对于每个位置的数据，在最后一次set后（后续对该位置再没有set，只有setAll），数据值随事件变化是非增的，因为setAll不会导致数据增大。
因此，在读取某一位置数据时，首先可以通过其更新时间戳得到最后一次set的时间，则晚于该时间后所有setAll更新中的最小值就是该位置数据应有的值。看来我们需要维护所有setAll操作的更新值，如此便通过求后缀最小值来获得晚于任意时间所有setAll更新中的最小值。
由于读取只有一次（最后每个位置读一次），那么后缀最小值也只需要在读取操作之前独立求得即可。

因此整体的时间复杂度 = 事件更新 $O(m)$ + setAll后缀最小值 $O(m)$ + 读取所有值 $O(n)$ = $O(m + n)$，线性时间复杂度完美AC。


## Problem D: 护送记者

### 题干回忆

> 公司邀请了n位记者来自动驾驶测试场地参观，自动驾驶场地由等距分布的纵横交叉的双向道路构成，相邻路口之间的距离为1公里。
> 现在n位记者散落在场地中各个路口，需要从基地派一辆自动驾驶汽车接他们回到基地参加发布会。出于安全考虑，每辆自动驾驶汽车必须配备一位安全员和一位测试员，因此一次最多只能载2位记者。
> 给定基地（x, y）和各记者的位置（xi, yi），求把所有记者安全接回基地所需要的最小公里数。

### 输入输出

* 输入
  * 第一行 n x y
  * 接下来有n行，每行表示第i位记者的坐标 xi yi
* 输出
  * 第一行 安全护送全部记者回到基地所需的最小公里数

### 数据范围

* $1 \le n \le 24$
* $-100 \le x, y, x_i, y_i \le 100$


## Problem E: 垃圾分类

### 题干回忆

> 小蔡所在的社区施行了最新的垃圾分类政策！主要有两种分类方式：（A）根据垃圾的处理方式分为n类；（B）根据垃圾的大小分为m类。
> 扔垃圾时相同处理方式的垃圾可以一起扔在同一个垃圾桶，相同大小的垃圾也可以扔在同一个垃圾桶。
> 社区共有n+m个垃圾桶，每个分类各一个。
> 目前小蔡手头有k个垃圾，第i个垃圾的处理方式分类为xi，大小分类为yi。求要丢完所有垃圾，至少需要去多少个垃圾桶扔垃圾。

### 输入输出

* 输入
  * 第一行 n m k
  * 接下来有k行，每行表示该垃圾的处理方式分类和大小分类 xi yi
* 输出
  * 第一行 丢完所有垃圾所需要拜访的最小垃圾桶数量

### 数据范围

* $1 \le n, m \le 10^9$
* $1 \le k \le 300$
* $1 \le x_i \le n$
* $1 \le y_i \le m$

